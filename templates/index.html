<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Initial Setup -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UB SEDS Ground Station</title>

  <!-- Importing all CSS styles -->
  <link rel="stylesheet" href="../static/css/styles.css">
  <link rel="stylesheet" href="../static/css/bootstrap.min.css">
  <link rel="stylesheet" href="../static/css/ol.min.css">

  <!-- Importing all JS Libraries -->
  <script src="../static/js/socket.io.js"></script>
  <script src="../static/js/chart.umd.js"></script>
  <script src="../static/js/justgage.js"></script>
  <script src="../static/js/raphael-2.1.4.min.js"></script>
  <script src="../static/js/ol.min.js"></script>
  <script src="../static/js/three.min.js"></script>
  <script src="../static/js/OBJLoader.js"></script>
  <script src="../static/js/OrbitControls.js"></script>
</head>

<!-- The ground station is broken into 3 main parts: the header which is always visible and the telemetry/map views -->
<!-- The telemetry and map views can be toggled with a button -->
<!-- The initial state has the telemetry view visible and the map view invisible -->
<!-- Entire ground station uses bootstrap which divides all vertical space into 12 columns and horizontal spaec into rows-->
<body>
  <div class="container-fluid">
    <div class=row id="header">
      <!-- Header Div which contains 4 columns for images-->
      <div class="col-md-4">
        <img src="../static/img/logo.png" class="logo" alt="logo">
        <img src="../static/img/ground-station-text.png" class="ground-station-text" alt="Ground Station">
      </div>
      <!-- 8 columns justified to the left for cards/test buttons -->
      <div class="col-md-8">
        <div class="row justify-content-end">
          <!-- Testing buttons, activated with an event listener -->
          <div class="col-md-auto">
            <button type="button" class="test-button btn-primary btn-lg ejection">Ejection</button>
          </div>
          <div class="col-md-auto">
            <button type="button" class="test-button btn-primary btn-lg reefing">Reefing</button>
          </div>
          <!-- All telemetry cards -->
          <div class="col-md-auto">
            <div class="card">
              <div class="card-body">
                <h5 class="card-title text-center">Status</h5>
                <!-- This needs to be addressed, if we lose connection, it should say disconnected, but what criteria determine this? -->
                <p class="card-text text-center">Connected</p>
              </div>
            </div>
          </div>
          <div class="col-md-auto">
            <div class="card">
              <div class="card-body">
                <h5 class="card-title text-center">Phase</h5>
                <p id="phase" class="card-text text-center">-</p>
              </div>
            </div>
          </div>
          <div class="col-md-auto">
            <div class="card">
              <div class="card-body">
                <h5 class="card-title text-center">Time</h5>
                <p id="time" class="card-text text-center">-</p>
              </div>
            </div>
          </div>
          <div class="col-md-auto">
            <div class="card">
              <div class="card-body">
                <h5 class="card-title text-center">Voltage</h5>
                <p id="voltage" class="card-text text-center">-</p>
              </div>
            </div>
          </div>
          <div class="col-md-auto">
            <div class="card">
              <div class="card-body">
                <h5 class="card-title text-center">Ping</h5>
                <p id="ping" class="card-text text-center">-</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Telemetry container, contains (mostly) all information, visible on startup -->
  <div class="container-fluid" id="telemetryContainer">
    <!-- This is questionable, I think this should mean that it takes up 80% of the screen height, but it seems inconsistent -->
    <div class="row" style="height: 80vh;">
      <!-- Occupies the left side of screen (3 columns) -->
      <div class="col-md-3">
        <!-- Kalman Acceleration Chart -->
        <div class="chart-container accel">
          <canvas id="accelChart" style="height: 100%; width: 100%;"></canvas>
        </div>
        <!-- Vertical placement in the HTML determines the veritcal placement in the webpage -->
        <!-- Kalman Velocity Chart -->
        <div class="chart-container velocity">
          <canvas id="velocityChart" style="height: 100%; width: 100%;"></canvas>
        </div>
      </div>
      <!-- Occupies middle of the screen (6 columns) -->
      <div class="col-md-6">
        <!-- Kalmnan Alitude Chart -->
        <div class="chart-container altitude">
          <canvas id="altitudeChart" style="height: 100%; width: 100%;"></canvas>
        </div>
      </div>
      <!-- Occupies right side of the screen -->
      <div class="col-md-3">
        <!-- Creating row inside the right-hand side div, divided in half for temperature and pressure guage -->
        <div class="row"">
          <!-- 6 columns for each gauge -->
          <div class=" col-md-6">
          <div class="gauge-container">
            <div id="temperatureGauge"></div>
          </div>
        </div>
        <div class="col-md-6">
          <div class="gauge-container">
            <div id="pressureGauge"></div>
          </div>
        </div>
      </div>
      <!-- Another row for the raw data chart, height style questionable though -->
      <div class="row raw-data" style="height: 16%;">
        <div class="col-md-12">
          <table class="table">
            <thead>
              <tr>
                <th class="text-center">Raw Acc-X</th>
                <th class="text-center">Raw Acc-Y</th>
                <th class="text-center">Raw Acc-Z</th>
                <th class="text-center">Raw Alt</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td id="raw-acc-x" class="text-center">-</td>
                <td id="raw-acc-y" class="text-center">-</td>
                <td id="raw-acc-z" class="text-center">-</td>
                <td id="raw-alt" class="text-center">-</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <!-- Another row for the rocket model -->
      <div class="row" style="height: 52.5%;">
        <div id="rocket-model" class="rocket-model"></div>
      </div>
    </div>
  </div>
  </div>
  <!-- Map container div,initially hidden -->
  <div class="container-fluid" id="mapContainer" style="display: none; height: 80vh;"></div>
  <!-- Div to contain the toggle button -->
  <div class="container mt-4">
    <div class="row justify-content-center">
      <div class="col-md-auto">
        <button class="btn map-button" onclick="toggleTelemetry()">Map</button>
      </div>
    </div>
  </div>

  <!-- All functinoality from here on out -->
  <script>
    function toggleTelemetry() {
      let telemetryContainer = document.getElementById("telemetryContainer");
      let mapContainer = document.getElementById("mapContainer");
      let button = document.querySelector(".map-button");

      if (telemetryContainer.style.display === "none") {
        telemetryContainer.style.display = "block";
        mapContainer.style.display = "none";
        button.textContent = "Map";
      } else {
        telemetryContainer.style.display = "none";
        mapContainer.style.display = "block";
        button.textContent = "Telemetry";
      }
    }
  </script>
  <script>

    // The flight computer creates data which it sends over radio as packets (68 bytes)
    // The radio on the ground is connected to the ground station via a serial port 
    // The app.py does two things simultaneously 
    // one thread runs a flask webserver
    // the other decodes the packets and creates JSON objects of all the data
    // The JSON objects are sent to the ground station via a socketio socket in the webserver, which updates the gruond station with data in real time

    // All JS Libraries must be locally available so we can use the ground station in the desert where we won't have connection
    // All libraries have a build version in the static/js folder

    // Initializing the socket, socketio library
    let socket = io();
    socket.on('connect', function () {
      console.log('Connected to server');
    });
    socket.on('disconnect', function () {
      console.log('Disconnected from server');
    });

    // Function to create charts, each plot is versus time, so we have 2 arrays, one is populated with time data, and one with actual data
    // Using chartjs libary and the rest of the implementation comes from the documentation
    function createChart(canvasId, label, yLabel) {
      let data = [];
      let timeData = [];
      // All HTML elements can have an ID, and be retreived by getElementById and have things places inside those divs
      let ctx = document.getElementById(canvasId).getContext("2d");
      let chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: label,
            data: data,
            borderColor: '  ',
            fill: false,
            pointRadius: 2,
          }]
        },
        options: {
          scales: {
            x: {
              title: {
                display: true,
                text: 'Time (s)'
              }
            },
            y: {
              title: {
                display: true,
                text: yLabel
              }
            }
          },
          plugins: {
            legend: {
              display: false // Hide the legend
            },
            title: {
              display: true,
              text: label + ' vs Time' // Set the title text
            }
          }
        }
      });

      return { data, timeData, chart };
    }

    // All chart objects
    let { data: accelData, timeData: accelTimeData, chart: accelChart } = createChart("accelChart", "Acceleration", "Acceleration (m/s^2)");
    let { data: altitudeData, timeData: altitudeTimeData, chart: altitudeChart } = createChart("altitudeChart", "Altitude", "Altitude (m)");
    let { data: velocityData, timeData: velocityTimeData, chart: velocityChart } = createChart("velocityChart", "Velocity", "Velocity (m/s)");

    // Create gauges using justgage.js and raphael.js (logic and drawing respectively)
    let temperatureGauge = new JustGage({
      id: "temperatureGauge",
      value: 0,
      min: 30,
      max: 90,
      title: "Temperature",
      label: "°C",
      decimals: true
    })

    let pressureGauge = new JustGage({
      id: "pressureGauge",
      value: 0,
      min: 50,
      max: 120,
      title: "Pressure",
      label: "kPa",
      decimals: true
    })

    // OpenLayers Map

    let map;

    // Initializes a map
    function initMap() {
      console.log("Loading map...");
      map = new ol.Map({
        target: "mapContainer",
        // Open street map
        layers: [
          new ol.layer.Tile({
            source: new ol.source.OSM()
          })
        ],
        view: new ol.View({
          center: ol.proj.fromLonLat([-107, 33]),
          zoom: 5,
          // maxZoom: 5
        })
      });
      map.getView().on('change:resolution', function () {
        const zoom = map.getView().getZoom();
        console.log('Current zoom level:', zoom);
      });
    }

    // Only when the map div is loaded will
    window.onload = initMap;

    // Adds marker at the specified latitude and longitude point on the map
    function addMarker(lon, lat) {
      map.getLayers().forEach(layer => {
        if (layer instanceof ol.layer.Vector) {
          layer.getSource().clear();
        }
      });

      let marker = new ol.Feature({
        geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat]))
      });

      let markerStyle = new ol.style.Style({
        image: new ol.style.Icon({
          src: "../static/img/marker.png",
          scale: 0.1
        })
      });

      marker.setStyle(markerStyle);

      let vectorSource = new ol.source.Vector({
        features: [marker]
      });

      let vectorLayer = new ol.layer.Vector({
        source: vectorSource
      });

      map.addLayer(vectorLayer);
    }

    function sendTestPacket(action) {
      socket.emit('testingPacket', action);
    }

<<<<<<< Updated upstream
    // Sending packet back to the web server over the socket
    document.querySelectorAll('.test-button').forEach(function(button) {
=======
    document.querySelectorAll('.test-button').forEach(function (button) {
>>>>>>> Stashed changes
      button.addEventListener('click', function () {
        const buttonText = button.textContent.trim();
        if (buttonText === "Ejection") {
          sendTestPacket("d");
        } else if (buttonText === "Reefing") {
          sendTestPacket("m");
        }
      });
    });

<<<<<<< Updated upstream
    // Code to render the rocket model using Threejs
    // A threejs scene contains everything, for us it has a camera, lightsource, and the model itself
    // Rotation to be implemented
=======
    let rocketModel;
    let gyroData = {x: 0, y: 0, z: 0};

>>>>>>> Stashed changes
    document.addEventListener("DOMContentLoaded", function () {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(50, window.innerHeight / window.innerWidth, 0.1, 1000);
      const modelContainer = document.getElementById('rocket-model');
      const renderer = new THREE.WebGLRenderer();
      const control = new THREE.OrbitControls(camera, renderer.domElement);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0xffffff);
      renderer.setSize(modelContainer.clientWidth, modelContainer.clientHeight);
      modelContainer.appendChild(renderer.domElement);

      const axesHelper = new THREE.AxesHelper(500);
      scene.add(axesHelper);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 400, 400);
      scene.add(directionalLight);

      const loader = new THREE.OBJLoader();
      loader.load('../static/assets/rocket.obj', function (obj) {
        obj.scale.set(0.14, 0.14, 0.14);
        obj.position.y = 150;
        rocketModel = obj;
        scene.add(obj);
      }, function (xhr) {
        console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
      }, function (error) {
        console.error("Error loading model: " + error);
      });

      camera.position.set(0, 0, 500);

      function animate() {
        requestAnimationFrame(animate);
        if (rocketModel) {
          rocketModel.rotation.x += gyroData.x/5000;
          rocketModel.rotation.y += gyroData.y/5000;
          rocketModel.rotation.z += gyroData.z/5000;
        }
        controls.update();
        renderer.render(scene, camera);
      }

      animate();
    });

    let lastPacketTime = null;
    let startTime = performance.now();

    // Loading all packet data into their corresponding functions/divs
    socket.on('data', function (packet) {
      document.getElementById('phase').innerText = packet.phase;
      document.getElementById('voltage').innerText = packet.batt_v + ' V';
      document.getElementById('time').innerText = Math.round((packet.millis / 1000) * 100) / 100 + ' S';
      document.getElementById('raw-acc-x').innerText = Math.round(packet.raw_acc[0] * 1000) / 1000;
      document.getElementById('raw-acc-y').innerText = Math.round(packet.raw_acc[1] * 1000) / 1000;
      document.getElementById('raw-acc-z').innerText = Math.round(packet.raw_acc[2] * 1000) / 1000;
      document.getElementById('raw-alt').innerText = Math.round(packet.raw_alt * 1000) / 1000;

      let currentPacketTime = performance.now();
      let ping = lastPacketTime
        ? Math.round(currentPacketTime - lastPacketTime) + ' ms'
        : 'N/A';
      lastPacketTime = currentPacketTime;

      document.getElementById('ping').innerText = ping;

      accelData.push(packet.acc);
      accelTimeData.push(Math.round((packet.millis / 1000) * 100) / 100);
      accelChart.data.labels = accelTimeData;
      accelChart.data.datasets[0].data = accelData;
      accelChart.update();

      altitudeData.push(packet.alt);
      altitudeTimeData.push(Math.round((packet.millis / 1000) * 100) / 100);
      altitudeChart.data.labels = altitudeTimeData;
      altitudeChart.data.datasets[0].data = altitudeData;
      altitudeChart.update();

      velocityData.push(packet.vel);
      velocityTimeData.push(Math.round((packet.millis / 1000) * 100) / 100);
      velocityChart.data.labels = velocityTimeData;
      velocityChart.data.datasets[0].data = velocityData;
      velocityChart.update();

      temperatureGauge.refresh(packet.temp);
      pressureGauge.refresh(Math.round((packet.pressure / 1000) * 100) / 100)

      addMarker(packet.lon, packet.lat);

      gyroData.x = packet.ang_vel_vector[0];
      gyroData.y = packet.ang_vel_vector[1];
      gyroData.z = packet.ang_vel_vector[2];
    });
  </script>
</body>

</html>


